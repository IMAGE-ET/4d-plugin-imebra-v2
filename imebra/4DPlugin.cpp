/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Imebra
 #	author : miyako
 #	2016/12/06
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"


void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
// --- Imebra

		case 1 :
			Imebra_Get_images(pResult, pParams);
			break;

	}
}

// ------------------------------------ Imebra ------------------------------------

void Imebra_Get_images(sLONG_PTR *pResult, PackagePtr pParams)
{
	//$0: text (JSON)
	C_TEXT returnValue;
	
	//$2: ARRAY PICTURE (out)
	PA_Variable Param2 = *((PA_Variable*) pParams[1]);
	
	switch (Param2.fType)
	{
		case eVK_ArrayPicture:
			break;
		case eVK_Undefined:
			PA_ClearVariable(&Param2);
			Param2 = PA_CreateVariable(eVK_ArrayPicture);
			break;
		default:
			break;
	}
	
	//$1: BLOB (DICOM)
	PA_Handle h = *(PA_Handle *)(pParams[0]);
	
	if(h)
	{
		unsigned int size = PA_GetHandleSize(h);
		
		imebra::ReadMemory mem((const char *)PA_LockHandle(h), size);
		imebra::MemoryStreamInput input(mem);
		imebra::StreamReader reader(input);
		
		std::unique_ptr<imebra::DataSet> data(imebra::CodecFactory::load(reader));
		
		/* get tags */
		
		imebra::tagsIds_t tags = data->getTags();
		
		JSONNODE *json_root = json_new(JSON_ARRAY);
		
		for (imebra::tagsIds_t::iterator it = tags.begin() ; it != tags.end(); ++it)
		{
			imebra::TagId t = *it;
			
			//tag properties
			std::uint16_t tagId = t.getTagId();
			std::uint16_t groupId = t.getGroupId();
			std::uint32_t groupOrder = t.getGroupOrder();

			imebra::Tag *tag = data->getTag(t);
			imebra::tagVR_t dataType = tag->getDataType();
			std::wstring tagDataTypeName;
			tagDataTypeName += ((int)dataType >> 8);
			tagDataTypeName += ((int)dataType&0xFF);
			size_t bufferId = 0;
			
			while (data->bufferExists(t, bufferId))
			{
				std::wstring w = data->getUnicodeString(t, bufferId, L"");
				
				JSONNODE *json_node = json_new(JSON_NODE);
				json_push_back(json_node, json_new_a(L"type", tagDataTypeName.c_str()));
				json_push_back(json_node, json_new_i(L"id", tagId));
				json_push_back(json_node, json_new_i(L"group", groupId));
				json_push_back(json_node, json_new_i(L"order", groupOrder));
				json_push_back(json_node, json_new_i(L"index", bufferId));
				json_push_back(json_node, json_new_a(L"value", w.c_str()));
				json_push_back(json_root, json_node);
				
				bufferId++;
			}
		}
		
		json_char *s = json_write_formatted(json_root);
		std::wstring w = std::wstring(s);
		
#if VERSIONMAC
		NSString *json = [[NSString alloc]
									 initWithBytes:w.c_str()
									 length:w.size()*sizeof(wchar_t)
									 encoding:NSUTF32LittleEndianStringEncoding];
//		NSLog(@"%s\n", [json UTF8String]);
		returnValue.setUTF16String(json);
		[json release];
#endif
		
		json_free(s);
		json_delete(json_root);
		
		/* get images */
		
		size_t page = 0;
		
		imebra::Image *image;
		
		do
		{
			image = NULL;
			try{
				image = data->getImageApplyModalityTransform(page);
			}catch(...)
			{
				break;
			}
			
		if(image)
		{
			page++;
			
			std::string colorSpace = imebra::ColorTransformsFactory::normalizeColorSpace(image->getColorSpace());

			std::uint32_t width = image->getWidth();
			std::uint32_t height = image->getHeight();
			
//			NSLog(@"colorspace:%s, width:%i, height:%i\n", colorSpace.c_str(), width, height);
			
			std::unique_ptr<imebra::ReadingDataHandlerNumeric> dataHandler(image->getReadingDataHandler());
			
//			size_t bytesPerValue = dataHandler->getUnitSize();
//			bool isSigned = dataHandler->isSigned();
			
//			NSLog(@"pixel_size:%zu, signed:%i\n", bytesPerValue, isSigned);
			
			imebra::TransformsChain chain;
			
			if(imebra::ColorTransformsFactory::isMonochrome(image->getColorSpace()))
			{
				
				int depth = 8;
				int dpi = 96;
				
				imebra::VOILUT voilutTransform;
				imebra::vois_t vois = data->getVOIs();
				std::list<std::shared_ptr<imebra::LUT> > luts;
				for(size_t scanLUTs(0); ; ++scanLUTs)
				{
					try
					{
						luts.push_back((std::shared_ptr<imebra::LUT>)data->getLUT(imebra::TagId(imebra::tagId_t::VOILUTSequence_0028_3010), scanLUTs));
					}
					catch(...)
					{
						break;
					}
				}
				if(!vois.empty())
				{
					voilutTransform.setCenterWidth(vois[0].center, vois[0].width);
				}
				else if(!luts.empty())
				{
					voilutTransform.setLUT(*(luts.front().get()));
				}
				else
				{
					voilutTransform.applyOptimalVOI(*image, 0, 0, width, height);
				}
				chain.addTransform(voilutTransform);
				imebra::DrawBitmap draw(chain);
				size_t requestedBufferSize = draw.getBitmap(*image, imebra::drawBitmapType_t::drawBitmapRGBA, 4, 0, 0);
				std::string buffer(requestedBufferSize, char(0));
				bool gotBitmap = 1;
				try{
					draw.getBitmap(*image, imebra::drawBitmapType_t::drawBitmapRGBA, 4, &(buffer.at(0)), requestedBufferSize);
				}catch(...)
				{
					gotBitmap = 0;
				}
				if(gotBitmap)
				{
					png_structp png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
					if(png_ptr)
					{
						png_infop info_ptr = png_create_info_struct(png_ptr);
						if(info_ptr)
						{
							if(setjmp(png_jmpbuf(png_ptr)))
							{
								png_destroy_write_struct(&png_ptr, &info_ptr);
							}else
							{
								C_BLOB png;
								png_set_write_fn(png_ptr, (png_voidp)&png, write_data_fn, output_flush_fn);
								
								png_set_IHDR (png_ptr,
															info_ptr,
															width,
															height,
															depth,
															PNG_COLOR_TYPE_RGB_ALPHA,
															PNG_INTERLACE_NONE,
															PNG_COMPRESSION_TYPE_DEFAULT,
															PNG_FILTER_TYPE_DEFAULT);
								
								png_set_pHYs(png_ptr, info_ptr,
														 dpi * INCHES_PER_METER,
														 dpi * INCHES_PER_METER,
														 PNG_RESOLUTION_METER);
								
								png_byte **row_pointers = (png_byte **)png_malloc(png_ptr, height * sizeof (png_byte *));
								
								char * buffer_p = &(buffer.at(0));
								for(std::uint32_t scanY(0); scanY < height; ++scanY)
								{
									png_byte *row = (png_byte *)png_malloc(png_ptr, sizeof (uint8_t) *width * 4);
									row_pointers[scanY] = row;
									
									for(std::uint32_t scanX(0); scanX < width; ++scanX)
									{
										*row++ = *buffer_p++;
										*row++ = *buffer_p++;
										*row++ = *buffer_p++;
										*row++ = *buffer_p++;
									}
								}
								
								png_write_info(png_ptr, info_ptr);
								png_set_rows (png_ptr, info_ptr, row_pointers);
								png_write_png (png_ptr, info_ptr, PNG_TRANSFORM_IDENTITY, NULL);
								png_write_end(png_ptr, info_ptr);
								png_destroy_write_struct(&png_ptr, &info_ptr);
								
								for(std::uint32_t scanY(0); scanY != height; ++scanY)
								{
									png_free(png_ptr, row_pointers[scanY]);
								}
								png_free (png_ptr, row_pointers);
								
								if(Param2.fType == eVK_ArrayPicture)
								{
									PA_Picture picture = PA_CreatePicture((void *)png.getBytesPtr(), png.getBytesLength());
									
									PA_ResizeArray(&Param2, page);
									PA_SetPictureInArray(Param2, page, picture);
									
									PA_Variable *pParam2 = ((PA_Variable *)pParams[1]);
									pParam2->fType = Param2.fType;
									pParam2->fFiller = Param2.fFiller;
									pParam2->uValue.fArray.fCurrent = Param2.uValue.fArray.fCurrent;
									pParam2->uValue.fArray.fNbElements = Param2.uValue.fArray.fNbElements;
									pParam2->uValue.fArray.fData = Param2.uValue.fArray.fData;
									PA_YieldAbsolute();
								}
							}
						}
					}
				}
			}else
			{
				int depth = 8;
				int dpi = 96;
				
				if(colorSpace != "RGB")
				{
					imebra::Transform *colorSpaceTransform = imebra::ColorTransformsFactory::getTransform(colorSpace, "RGB");
					chain.addTransform(*colorSpaceTransform);
					
				}

				imebra::DrawBitmap draw(chain);
				size_t requestedBufferSize = draw.getBitmap(*image, imebra::drawBitmapType_t::drawBitmapRGBA, 4, 0, 0);
				std::string buffer(requestedBufferSize, char(0));
				bool gotBitmap = 1;
				try{
					draw.getBitmap(*image, imebra::drawBitmapType_t::drawBitmapRGBA, 4, &(buffer.at(0)), requestedBufferSize);
				}catch(...)
				{
					gotBitmap = 0;
				}
				if(gotBitmap)
				{
					png_structp png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
					if(png_ptr)
					{
						png_infop info_ptr = png_create_info_struct(png_ptr);
						if(info_ptr)
						{
							if(setjmp(png_jmpbuf(png_ptr)))
							{
								png_destroy_write_struct(&png_ptr, &info_ptr);
							}else
							{
								C_BLOB png;
								png_set_write_fn(png_ptr, (png_voidp)&png, write_data_fn, output_flush_fn);
								
								png_set_IHDR (png_ptr,
															info_ptr,
															width,
															height,
															depth,
															PNG_COLOR_TYPE_RGB_ALPHA,
															PNG_INTERLACE_NONE,
															PNG_COMPRESSION_TYPE_DEFAULT,
															PNG_FILTER_TYPE_DEFAULT);
								
								png_set_pHYs(png_ptr, info_ptr,
														 dpi * INCHES_PER_METER,
														 dpi * INCHES_PER_METER,
														 PNG_RESOLUTION_METER);
								
								png_byte **row_pointers = (png_byte **)png_malloc(png_ptr, height * sizeof (png_byte *));
								
								char * buffer_p = &(buffer.at(0));
								for(std::uint32_t scanY(0); scanY < height; ++scanY)
								{
									png_byte *row = (png_byte *)png_malloc(png_ptr, sizeof (uint8_t) *width * 4);
									row_pointers[scanY] = row;
									
									for(std::uint32_t scanX(0); scanX < width; ++scanX)
									{
										*row++ = *buffer_p++;
										*row++ = *buffer_p++;
										*row++ = *buffer_p++;
										*row++ = *buffer_p++;
									}
								}
								
								png_write_info(png_ptr, info_ptr);
								png_set_rows (png_ptr, info_ptr, row_pointers);
								png_write_png (png_ptr, info_ptr, PNG_TRANSFORM_IDENTITY, NULL);
								png_write_end(png_ptr, info_ptr);
								png_destroy_write_struct(&png_ptr, &info_ptr);
								
								for(std::uint32_t scanY(0); scanY != height; ++scanY)
								{
									png_free(png_ptr, row_pointers[scanY]);
								}
								png_free (png_ptr, row_pointers);
								
								if(Param2.fType == eVK_ArrayPicture)
								{
									PA_Picture picture = PA_CreatePicture((void *)png.getBytesPtr(), png.getBytesLength());
									
									PA_ResizeArray(&Param2, page);
									PA_SetPictureInArray(Param2, page, picture);
									
									PA_Variable *pParam2 = ((PA_Variable *)pParams[1]);
									pParam2->fType = Param2.fType;
									pParam2->fFiller = Param2.fFiller;
									pParam2->uValue.fArray.fCurrent = Param2.uValue.fArray.fCurrent;
									pParam2->uValue.fArray.fNbElements = Param2.uValue.fArray.fNbElements;
									pParam2->uValue.fArray.fData = Param2.uValue.fArray.fData;
									PA_YieldAbsolute();
								}
							}
						}
					}
				}
			}
		}
			
		}while(image);

		PA_UnlockHandle(h);
	}
	returnValue.setReturn(pResult);
}

void write_data_fn(png_structp png_ptr, png_bytep buf, png_size_t size){
	C_BLOB *blob = (C_BLOB *)png_get_io_ptr(png_ptr);
	blob->addBytes((const uint8_t *)buf, (uint32_t)size);
}

void output_flush_fn(png_structp png_ptr)
{
	
}